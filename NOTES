
* float/double is a factor of 2 in space, we need it for lattice objects

* Types of stored objects

     .complexFloat                          COMPOSITE(r: FLOAT, i: FLOAT)
     .complexDouble                         COMPOSITE(r: DOUBLE, i: DOUBLE)
     .ColorVectorFloatN                     ARRAY(.complexFloat, {N})
     .ColorVectorDoubleN                    ARRAY(.complexDouble, {N})
     .ColorMatrixFloatNxM                   ARRAY(.complexFloat, {N,M})
     .ColorMatrixDoubleNxM                  ARRAY(.complexDouble, {N,M})
     .DiracFermionFloatN                    ARRAY(.ColorVectorFloatN, {4})
     .DiracFermionDoubleN                   ARRAY(.ColorVectorDoubleN, {4})
     .DiracPropagatorFloatNxM               ARRAY(.ColorMatrixFloatNxM, {4,4})
     .DiracPropagatorDoubleNxM              ARRAY(.ColorMatrixDoubleNxM, {4,4})

* Lattice objects are written an D-dim datasets with each node contributing data for its hyperblock.
* Lattice: size is in S->dim, rank is S->rank
* Local sublattice can be computed by qlua_sublattice(lo, hi, QDP_this_node, S);
* Running over the D-dim points x, qlua_layout.index(S->lat, x) will produce the local linear address corresponding to x.
* Default slab is ({0,...}, S->dim)

* Use QMP_comm_binary_reduction() to compute the lattice checksum
* The same reduce function may be use to combine lattice sites.

* Attributes are used only to store information useful for qlua:
** .kind is a string uniquely describing dataset
** .sha256 is the SHA256 of all the data, including default values
** no need to store lattice size, as it is computable from the dataset metadata

* writer may specify float vs double as precision
* reader injests both floats and doubles
* one can overwrite .kind in the reader with an additional argument

* Writer:write("/path/to/data/set", object [,{precision = precision, slab={low = {lo-x, ...}, high = {hi-x, ...}}}])

* Reader:read("/path/to/data/set" [, {lattice = lat, kind = "kind of data"}])

* Kinds if there is "kind" attribute, its value is one of the following:

    "String"                      H5I_DATASET
    "Real"                        H5I_DATASET
    "Complex"                     H5I_DATASET
    "MatrixReal"                  H5I_DATASET
    "MatrixComplex"               H5I_DATASET
    "VectorInt"                   H5I_DATASET
    "VectorReal"                  H5I_DATASET
    "VectorComplex"               H5I_DATASET
    "ColorVector"                 H5I_DATASET
    "ColorMatrix"                 H5I_DATASET
    "DiracFermion"                H5I_DATASET
    "DiracPropagator"             H5I_DATASET
    "LatticeInt"                  H5I_DATASET
    "LatticeReal"                 H5I_DATASET
    "LatticeComplex"              H5I_DATASET
    "LatticeColorVector"          H5I_DATASET
    "LatticeColorMatrix"          H5I_DATASET
    "LatticeDiracFermion"         H5I_DATASET
    "LatticeDiracPropagator"      H5I_DATASET

* other HDF5 elements without corresponding qlua objects have implicit kinds:

    "Group"                     H5I_GROUP
    "DataSpace"                 H5I_DATASPACE
    "DataSet"                   H5I_DATASET
    "DataType"                  H5I_DATATYPE
    "Attribute"                 H5I_ATTR
    "File"                      H5I_FILE
    "Unknown"                   default case, never happens
    

* writer:
   ** check the first argument
   ** create path if needed, get it's hid_t
   ** argument three is data
   ** argument four, if present is a table with optional parameters (only for lattice types)
   *** precision = "float" / "double", double is default
   *** slab = { low = {lo_x, ....}, high = {hi_x, ....}} select the hypercube to write

--------- rethink
* reader
   ** check the first argument
   ** get hid_t of the second argument
   ** set kind to NULL, set lattice to NULL
   ** if argument three is a lattice, remember it
   *** if there is a fourth argument, check that it's a string and remember it as kind
   ** if argument three is a string, remember it as kind
   ** if kind is NULL, get it from h
   ** dispatch on kind, call fn(L, b, h, lattice)

* add exists to the reader and the writer
[done] * rearrange sources: common, writer, reader routines.
[done] * change machine_complex to machine_dcomplex and add machine_fcomplex, two more complex type constructors etc.
* Q: How do we set the default value in a dataset?
* always construct full checksum