-- quda interface
do
   local inited = false;
   local solver = false;
   local lattice = false;
   local has_clover = false;
   qcd.quda = {};
   function qcd.quda.init(L)
      if inited then
         error("Quda is already inited");
      else
         _quda.setVerbosityQuda("SILENT");
         _quda.initCommsGridQuda(L);
         _quda.initQuda();
         lattice = L;
      end
      inited = true;
   end
   function qcd.quda.fini()
      if inited then
         if solver then
            solver:fini();
         end
         _quda.endQuda();
         lattice = false;
         inited = false;
      else
         error("Quda is not initialized\n");
      end
   end
   function qcd.quda.solver(U, gpx, ipx)
      local obj = {};
      local gparams = nil;
      local iparams = nil;
      function obj:close()
         if has_clover then
            _quda.freeCloverQuda();
            has_clover = false;
         end
         _quda.freeGaugeQuda();
         gparams = nil;
         iparams = nil;
         obj = {};
         solver = false;
      end
      function obj:solve(rhs)
         if not gparams then
            error("Solver is closed");
         end
         printf("\n-------------\nXXX qcd.quda.solver:solve() ... before solve iparams = \n"); iparams:print();
         printf("\n---------- XXXX calling invertQuda()\n");
         local sol = _quda.invertQuda(rhs, iparams);
         printf("-------------\nXXX qcd.quda.solver:solve() ... after solve iparams = \n"); iparams:print();
         printf("\n---------- XXX QI:solve() done()\n");
         return sol;
      end
      function obj:plaqs()
         if not gparams then
            error("Solver is closed");
         end
         return _quda.plaqQuda();
      end
      function obj:__gc()
         obj:close();
      end
      if not inited then
         error("qcd.quda is not initialized");
      end
      if solver then
         error("qcd.quda does not support multiple solvers");
      end
      local vol = lattice:volume();
      local i;
      local padding = 0;
      for i = 0, #L - 1 do
         local face = vol / lattice[i];
         if face > padding then
            padding = face;
         end
      end
      gparams = _quda.GaugeParam();
      gparams:set{type                = "WILSON_LINKS",
                  gauge_order         = "QDP_GAUGE_ORDER",
                  gauge_fix           = "GAUGE_FIXED_NO",
                  cpu_prec            = "DOUBLE_PRECISION",
                  ga_pad              = padding,
                  cuda_prec           = "DOUBLE_PRECISION",
                  reconstruct         = "RECONSTRUCT_NO",
                  cuda_prec_sloppy    = "HALF_PRECISION",
                  reconstruct_sloppy  = "RECONSTRUCT_12",
                  anisotropy          = 1.0,
                  X                   = {lattice[0],
                                         lattice[1],
                                         lattice[2],
                                         lattice[3]}};
      gparams:set(gpx);
      if not (#U == #lattice) then
         error("Wrong number of color matrices in the gauge field");
      end
      for i = 1, #L do
         if not (U[i].lattice == lattice) then
            error("Gauge field component on a wrong lattice");
         end
      end
      iparams = _quda.InvertParam();
      iparams:set{clover_cpu_prec           = "DOUBLE_PRECISION",
                  clover_cuda_prec          = "DOUBLE_PRECISION",
                  clover_cuda_prec_sloppy   = "HALF_PRECISION",
                  clover_order              = "PACKED_CLOVER_ORDER",
                  cpu_prec                  = "DOUBLE_PRECISION",
                  cuda_prec                 = "DOUBLE_PRECISION",
                  cuda_prec_sloppy          = "HALF_PRECISION",
                  dagger                    = "DAG_NO",
                  dirac_order               = "QDP_DIRAC_ORDER",
                  gamma_basis               = "DEGRAND_ROSSI_GAMMA_BASIS",
                  inv_type                  = "BICGSTAB_INVERTER",
                  mass_normalization        = "KAPPA_NORMALIZATION",
                  matpc_type                = "MATPC_EVEN_EVEN",
                  preserve_source           = "PRESERVE_SOURCE_NO",
                  reliable_delta            = 0.1,
                  solution_type             = "MAT_SOLUTION",
                  solve_type                = "DIRECT_PC_SOLVE",
                  sp_pad                    = padding,
                  cl_pad                    = padding,
                  tune                      = "TUNE_YES",
                  use_init_guess            = "USE_INIT_GUESS_NO",
                  verbosity                 = "SILENT"
               };
      iparams:set(ipx);
      _quda.loadGaugeQuda(U, gparams);
      if ((ipx.dslash_type == "CLOVER_WILSON_DSLASH") or
       (ipx.dslash_type == "TWISTED_CLOVER_DSLASH")) then
         _quda.loadCloverQuda(iparams);
         has_clover = true;
      end
      solver = obj;
      return obj;
   end
end
